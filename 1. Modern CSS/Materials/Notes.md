# Современный CSS

> 12 октября 2022 — лекция 1

### Классификация стилий

Есть наследуемые (например, `color`) и ненаследуемые (например, `padding`) стили.

### Комбинаторы селекторов

- Дочерний элемент: `.something .something {}`
- Прямой потомок: `.something > .children {}`
- Соседний элемент: `.something + .children {}`

### Переменные

```CSS
.something {
    --some-var: 100px;
}
.another-thing {
    width: var(--some-var);
}
```

### Сокращенные Свойства

```CSS
.something {
    /* all */
    margin: 10px;
    /* T/B L/R*/
    margin: 10px 20px;
    /* T L/R B*/
    margin: 10px 20px 15px;
    /* T R B L */
    margin: 10px 20px 15px 25px;
}
```

### Вендорные префиксы

```CSS
.something {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
```

### Media query

```CSS
@font-face {
    font-family: "YS Text";
    src: ...;
}
```

### Скрытие элемента

2 варианта:

- `display: none` — не виден, нельзя взаимодействовать, не занимает место
- `visibility: hidden` — не виден, нельзя взаимодействовать, занимает место
- `opacity: 0` — не виден, можно взаимодействовать, занимает место

### Блочная модель

Каждый блок состоит из:

- margin
- border
- padding

#### Box Sizing

`box-sizing` позволяет задавать режим работы `width` и `height`:

- `content-box`: `width` — ширина без `padding` и `border`
- `border-box`: `width` — итоговая ширина

Процентные значения всегда считаются от ширины элемента (для поддержки нормального потока).

#### Поток

1. Нормальный поток

   - зависит от направления письма
   - опирается на содержащий (родительский элемент или viewport

   Ширина = ширина содержащего блока - `margin-left - margin-right`.

   Расчет размеров: `ширина + border-left + padding-left + border-right + padding-right = ширина содержащего блока - margin-left - margin-right`.

   Margin может выходить за содержащий элекмент, если у него нет padding/border.
   Бывает "схлопывание" margin — вертикальные margin у соседних элементов могут объединиться чтобы итоговый отступ был равен наибольшему (избежать можно с помощью `flexbox`).

2. Поток флоатов
3. Flexbox

   Выравнивает элементы в строку или столбец. Имеет 2 оси: основная и дополнительная (перпендикулярна основной), задается с помощью `flex-direction` со значениями `column` и `row`. Все элементы содержут базовый (`flex-bases`) и минимальный размер, а также факторы увеличения/сжатия (`flex-grow`/`flex-shrink`). Свободное место распределяет между `margin: auto` и `justify-content`.

   Размещение вдоль побочной оси: `align-items` и `align-self` (у элемента). `align-content` — размещение строк относительно побочной оси.

4. Grid

   Сетка позволяет располагать элементы в строках и колонках, объединять, выравнивать их, изменять размеры и т.д.
   Ресурсы: MDN, Grid Garden.

### Строчный контекст

Элементом может быть не только текст.

- `display: inline-block` позволяет встроить элемент в строку.
- `text-align` — горизонтальное выравнивание.
- `line-height` — задает высоту прямоугольника внутри одной строки (нежелателен для выравнивание элементов по вертикали, не поддерживает 100%).
- `vertical-align` — вертикальное расположение прямоугольника для элемента внутри строки (не работает в блочном контексте). Значения: `top`, `bottom`, `middle`, пиксельные. Значение `middle` — не середина.

### Position

- Relative

  `top/right/bottom/left` — смещение относительно изначального расположения элемента.

- Absolute

  `top/right/bottom/left` — смещение относительно от первого родительского элемента с `position` не `static` (опорного). Часто используется с `position: relative` в качестве опорного элемента.

- Fixed

  Как и `absolute`, но опорный элемент — viewport.

### Наложение элементов

Есть виртуальная ось `Z`, чем больше значение `z-index` — тем позже (выше) будет нарисован элемент.

### Устаревшие раскладки

- Таблицы (до Flexbox и Grid)

  Не стоит использовать для интерфейса, но подходит для обычных таблиц с данными.

- Float

  Для обтекания текстом элемента. Использовать для структуры интерфейса не стоит.

### Советы

- разбирать непонятный код
- писать в едином стиле с минимальной вложенностью
- разбивать код на файлы и независимые компоненты
- придумать общие правила для z-index (например, объявлять переменные)
